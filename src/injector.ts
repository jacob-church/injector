import type { Ctor, InjectKey } from "./types/injectkey.ts";
import type { Provide } from "./types/provide.ts";
import {
    InjectError,
    InjectionStack,
    InjectorError,
    MissingProvideError,
    TooManyArgsError,
} from "./injecterror.ts";
import { ProvideKey } from "./providekey.ts";
import type { ConcreteUnion } from "./types/concreteunion.ts";
import {
    type ContextInjectable,
    DummyFactory,
    type InjectionContext,
} from "./types/injectioncontext.ts";

/**
 * Setup an injector
 *
 * @param provides (optional) a list of `Provide`
 * @param parent (optional) another injector to defer to when this injector is not specifically configured to handle a requested type
 *
 * @returns a configured Injector
 *
 * Usage:
 * ```typescript
 * const i = newInjector([
 *  provide(A).useExisting(MockA),
 * ]);
 * i.get(A) // MockA
 * ```
 */
export function newInjector(provides?: Provide[], parent?: Injector): Injector {
    return new Injector(provides, parent);
}

/**
 * As constrasted with "Provide", a Provided is what you get when you pass
 * a Provide into an Injector
 */
type Provided<T = unknown> = Provide<T> & {
    holder: Injector; // the Injector that holds this object
    value?: T;
    deps?: Built[]; // a record of other types that injected while assigning `value`
};
type Built<T = unknown> = Provided<T> & {
    value: T;
    deps: Built[];
};
function isBuilt<T>(provide: Provided<T>): provide is Built<T> {
    return typeof provide.deps !== "undefined";
}

const InjectionContextError =
    "No active injection context. Create an injector with `newInjector`.";
export class Injector {
    // STATIC ////////////////////////////////////////////////////////////////
    // when defined, an active injection context
    private static context: Injector | undefined = undefined;
    /**
     * By defining this inside the injector, we can keep `context` safe from
     * meddling, and we can access `getInContext` to skip redefining context, gobbling up stack space
     */
    public static inject<T>(key: InjectKey<T>): T {
        if (!Injector.context) {
            throw new Error(
                InjectionContextError,
            );
        }
        return Injector.context.getInContext(key);
    }
    /**
     * see `inject`
     */
    public static getInjectionContext<
        Args extends [ContextInjectable, ...ContextInjectable[]],
    >(...types: Args): InjectionContext<ConcreteUnion<Args>> {
        if (!Injector.context) {
            throw new Error(
                InjectionContextError,
            );
        }
        for (const key of types) {
            // creates the dummy object, and invokes needed cleanup, ensuring that dependencies are recorded
            // for any types to be generated by this context
            key[DummyFactory]().cleanup();
        }
        const context = Injector.context;
        return (fn: () => ConcreteUnion<Args>) => {
            const prevContext = Injector.context;
            Injector.context = context;
            try {
                return fn();
            } finally {
                Injector.context = prevContext;
            }
        };
    }

    public static getUnsafeInjectionContext(): InjectionContext {
        if (!Injector.context) {
            throw new Error(
                InjectionContextError,
            );
        }
        const context = Injector.context;
        // deno-lint-ignore no-explicit-any
        return (fn: () => any) => {
            const prevContext = Injector.context;
            Injector.context = context;
            try {
                return fn();
            } finally {
                Injector.context = prevContext;
            }
        };
    }
    /**
     * @returns the childmost injector (the injector of highest rank)
     */
    private static max(a: Injector, b: Injector): Injector {
        return a.rank > b.rank ? a : b;
    }
    // a provide that is currently being built, on the next stack frame up
    private static buildingProvide: Built | undefined = undefined;
    // MEMBERS ///////////////////////////////////////////////////////////////
    // the provides stored in this injector
    private provides = new Map<InjectKey, Provided>();
    // super fast get of objects already built by this injector
    private cache = new Map<InjectKey, Built>();
    // a quick reference for comparing where two injectors sit within the same hierarchy
    private rank: number;
    // PUBLIC ////////////////////////////////////////////////////////////////
    constructor(provides: Provide[] = [], private parent?: Injector) {
        provides.map((p) => this.setLocalProvide(p));
        this.rank = this.parent ? this.parent.rank + 1 : 0;
    }

    /**
     * Given a key
     * @returns a singleton of type T
     * The provide point into a valid injection context
     */
    public get<T>(key: InjectKey<T>): T {
        const prevInjector = Injector.context;
        Injector.context = this;
        try {
            return this.getInContext(key);
        } finally {
            Injector.context = prevInjector;
        }
    }

    /**
     * Creates a new Injector as a child to `this` Injector
     * @param provides (optional) provide configuration for the new Injector
     * @returns Injector
     */
    public child(provides: Provide[] = []): Injector {
        return new Injector(provides, this);
    }
    // PRIVATE ///////////////////////////////////////////////////////////////
    /**
     * Copies the minimum necessary information from a Provide into this injector,
     * marks that provide as held by this injector
     */
    private setLocalProvide(provide: Provide): void {
        this.provides.set(provide.key, {
            key: provide.key,
            factory: provide.factory,
            holder: this,
        });
    }
    /**
     * The actual `get` implementation; assumes an active injection context
     */
    private getInContext<T>(key: InjectKey<T>): T {
        InjectionStack.push(key);
        try {
            const built = this.cache.get(key) ?? this.getBuilt(key);
            if (Injector.buildingProvide) {
                // whenever a key is requested, its essential to tie the dependency
                // to a higher stack frame if there is one, for correct storage of entries
                Injector.buildingProvide.deps.push(built);
                Injector.buildingProvide.holder = Injector.max(
                    built.holder,
                    Injector.buildingProvide.holder,
                );
            }
            return built.value as T;
        } finally {
            InjectionStack.pop();
        }
    }

    /**
     * Fetches the most relevant provide and ensures it is ready to serve
     * (Assumes this key is not cached)
     */
    private getBuilt<T>(key: InjectKey<T>): Built<T> {
        const provide = this.getProvide(key);
        if (isBuilt(provide) && !this.needsRebuild(provide)) {
            return provide;
        }
        return this.buildAndStore(provide);
    }

    /**
     * Find the childmost provide for the given key; if none is found
     * an implicit provide is generated for the parent-most injector
     *
     * @param backstop optionally specify a boundary injector;
     * if a Provided has not been found before reaching this backstop,
     * return `undefined` instead (optimized for needsRebuild check)
     */
    private getProvide<T>(key: InjectKey<T>): Provided<T>;
    private getProvide<T>(
        key: InjectKey<T>,
        backstop: Injector | undefined,
    ): Provided<T> | undefined;
    private getProvide<T>(
        key: InjectKey<T>,
        backstop?: Injector | undefined,
    ): Provided<T> | undefined {
        const provide = this.provides.get(key);
        if (provide) {
            return provide as Provided<T>;
        }
        if (this == backstop) {
            return undefined;
        }
        if (this.parent) {
            return this.parent.getProvide(key, backstop);
        }
        if (key instanceof ProvideKey) {
            throw new MissingProvideError(key);
        }
        if (key.length > 0) {
            throw new TooManyArgsError(key);
        }
        return {
            key,
            factory: () => new (key as Ctor<T>)(),
            holder: this,
        };
    }

    /**
     * Given a provide, determine if it needs to be rebuilt in the current context
     */
    private needsRebuild(provide: Built): boolean {
        return !!this.getFirstOverridingInjector(provide, provide.holder)[0];
    }

    /**
     * Finds the first injector, if any, that overrides any provide in the
     * given dependency tree (recursive over transitive dependencies)
     *
     * For optimization purposes, this method will also mutate .cache and
     * .provides to speedup future lookups
     */
    private getFirstOverridingInjector(
        built: Built,
        currHolder: Injector,
        visited: Set<InjectKey> = new Set(),
    ): [Injector | undefined, boolean] {
        if (visited.has(built.key)) {
            return [undefined, false];
        }
        visited.add(built.key);

        // Step 1. check for overriding provide
        const cached = this.cache.get(built.key);
        const provide = cached ??
            this.getProvide(built.key, currHolder);
        if (provide && provide.holder.rank > currHolder.rank) {
            // any provider that is higher in the hierarchy than the provider
            // we kicked this off with is an indication rebuilding is necessary
            return [provide.holder, false];
        } else if (cached) {
            // cached keys are already assigned fully by this injector, so continuing is not needed either way
            return [undefined, false];
        }

        // Step 2. recurse
        for (const dep of built.deps) {
            const [overrideInjector, overwriteProvide] = this
                .getFirstOverridingInjector(dep, currHolder, visited);
            if (overrideInjector) {
                // "copying" the dep into the relevant injector, unbuilt, guarantees we can skip
                // wasteful calls to this needsRebuild in the future
                overwriteProvide && overrideInjector.setLocalProvide(dep);
                return [overrideInjector, true];
            }
        }

        // Step 3. reaching this point indicates no overriding provide was found, so we've
        // effectively determined "needRebuild" for this provide as well
        this.cacheBuilt(built);
        return [undefined, false];
    }

    /**
     * Given a Provided, takes the necessary steps to finalize that provide and cache it appropriately
     */
    private buildAndStore<T>(provide: Provided<T>): Built<T> {
        const built = { ...provide, deps: [] } as Built<T>;
        const prevBuildingProvide = Injector.buildingProvide;
        Injector.buildingProvide = built;
        try {
            built.value = built.factory();
        } catch (e) {
            if (e instanceof InjectorError) {
                throw e; // let these bubble up; we only wrap the error in a stack trace once
            } else {
                throw new InjectError(e as Error);
            }
        } finally {
            Injector.buildingProvide = prevBuildingProvide;
        }
        built.holder.provides.set(built.key, built); // overwrite in holder injector with the Built provide
        this.cacheBuilt(built);
        return built;
    }

    /**
     * Let every injector between this and provide.holder (inclusive)
     * know that the given provide has been built and assigned
     */
    private cacheBuilt<T>(provide: Built<T>): void {
        if (!this.cache.has(provide.key)) {
            this.cache.set(provide.key, provide);
            if (this !== provide.holder) {
                this.parent?.cacheBuilt(provide);
            }
        }
    }
}
